"""
直接选择排序

算法描述：
    首先找到最大的元素，将其余a[n-1]位置交换：
    然后在余下的n-1个元素中寻找最大的元素，将其余a[n-2]位置交换，如此进行下去直至n个元素排序完毕。

过程举例：
初始元素序列：    8, 3, 2, 5, 9, 3, 6
第一趟排序：      8, 3, 2, 5, 6, 3,[9]
第二趟排序：      3, 3, 2, 5, 6,[8, 9]
第三趟排序：      3, 3, 2, 5,[6, 8, 9]
第四趟排序：      3, 3, 2,[5, 6, 8, 9]
第五趟排序：      2, 3,[3, 5, 6, 8, 9]
第六趟排序：      2,[3, 3, 5, 6, 8, 9]


直接选择排序交换少，比较多。元素比较费劲时（如字符串比较）不建议此算法。
"""


def selection(a):
    print(f'排序前：{a}')
    n = len(a)
    counter = 0  # 用于记录排序趟数
    for i in range(n - 1, -1, -1):
        k = i
        j = i - 1
        while j >= 0:
            if a[j] > a[k]:
                k = j   # 获取每次遍历的最大值的下标
            j = j - 1
        if k != i:
            t = a[k]
            a[k] = a[i]
            a[i] = t
        counter = counter + 1
        print(f'第{counter}趟排序：{a}')
    print(f'排序后：{a}')


selection([8, 3, 2, 5, 9, 3, 6])
